# 数据结构

## 数据结构的实现

- 单向链表

```js
    class NodeList {
        private head;
        private last;
        private size;

        checkPosition(index) {
            if (index <= 0 || index > size) {
                return
            }
        }

        /**
         * @param data 插入数据
         * @param index 插入位置
         **/
        insert(data, index) {
            checkPosition(index);
            const insertNode = new Node(data);
            if (size === 0) {
                head = insertNode;
                last = insertNode;
            } else if (index === 0) {
                insertNode.next = head;
                head = insertNode
            } else if (index === size) {
                last.next = insertNode;
                last = insertNode
            } else {
                const preNode = this.get(index - 1);
                insertNode.next = insertNode;
                preNode.next = insertNode;
            }
        }

        remove(index) {
            checkPosition(index);
            if (index <= 0 || index > size) {
                return
            }
            let node = null;
            if (index === 0) {
                node = head;
                head = head.next;
            } else if (index === size) {
                const preNode = this.get(index - 1);
                preNode.next = null;
                last = preNode;
            } else {
                const node = this.get(index);
                const preNode = this.get(index - 1);
                preNode.next = node.next;
            }
        }

        get(index) {
            checkPosition(index);
            let temp = null;
            for(let i = 0; i < index; i++) {
                // 链表的查找需要依赖 next 指针
                temp = temp.next;
            }
            return temp;
        }

        private class Node {
            private next;
            constructor(data) {
                this.data = data;
            }
        }
    }
```

- 循环队列

```js
    class MyQueue {
        // 使用 front rear 来标记队列位置
        private front;
        private rear;
        private maxLen;

        constructor(len) {
            this.array = new Array(len);
            this.maxLen = len;
        }

        enQueue(data) {
            if (this.rear % (this.maxLen + 1) === front) {
                // 队列已满
                return
            }
            array[this.rear] = data;
            this.rear = (this.rear + 1) % this.maxLen;
        }

        deQueue() {
            if (rear === front) {
                // 空队列
                return
            }
            const deQueueElement = this.array[front];
            this.front = (this.front + 1) % maxLen;
            return deQueueElement
        }

    }
```


