<!--
 * @Author: your name
 * @Date: 2020-09-20 22:23:32
 * @LastEditTime: 2020-09-20 22:40:53
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \DesignPatterns\js基础\基础函数实现.md
-->

# 基础函数

## 防抖函数: delay时间内，相同操作指出发一次时间

    ```javascript
        var a = debunce(a, 300)();

        function debounce(fn, delay) {
            let timer = null;
            return () => {
                clearTimeout(timer);
                const args = arguments;
                timer = setTimeout(() => {
                    fn && fn.apply(this, arguments);
                }, delay);
            }
        }
    ```

## 截流函数 timeout 和时间戳两种实现方式: 某段时间内触发一次

    ```javascript
        const th = function(fn, delay) {
            let canRun = true;
            return function() {
                if(!canRun) return;
                canRun = false;
                setTimeout(() => {
                    // arguments 是返回函数的参数
                    fn && fn.apply(this, arguments);
                    canRun = true;
                }, delay)
            }
        }
    ```

## 数组 flat: 数组的扁平化，是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组

    ```javascript
        // [1, 2, [3, [4, [5]]]].flat(Infinity) => [1, 2, 3, 4, 5]
        1. reduce
            function flatten (arr) {
                return arr.reduce((cur, next) => {
                    return cur.concat(Array.isArray(next) ? flatten(next) : next);
                }, []);
            }
            // 数组的 toString 会将 [1,2,3,[1,2]] 转化为 1,2,3,1,2
        2. toString
            function flatten(arr) {
                return arr.toString().split(',').map(item => +item);
            }

        3. generator
            function* flatten(arr) {
                if (!Array.isArray(arr)) yield arr;
                else for(let el of arr) yield* flatten(el); 
            }

        4. 正则
            const flatten = arr => JSON.parse(`[${JSON.stringify(arr).replace(/\[|]/g,'')}]`);

        
    ```

## 广度优先遍历

    ``` javascript
        function wideTra(node) {
            let nodes = [];
            if(node) {
                nodes.push(node);
                wideTra(node.nextElementSibling); // 找出这一层 node 的所有兄弟节点
                node = nodes[i++]; // 切换到下一个节点
                wideTra(node.firstElement); // 找出这个 node 的 第一个子节点
            }
            return nodes;
        }
    ```

## [用深度优先思想和广度优先思想实现一个拷贝函数](https://blog.csdn.net/weixin_44248722/article/details/110090119)

## 实现 new, class

    ``` javascript
        function createObj() {
            const Function = [].shift.call(arguments);   // 获取第一个参数为 构造函数
            const obj = {}; // 传建一个空对象
            obj.__proto__ = Function.prototype;  // 基于原型 的继承
            const re = Function.apply(obj, arguments); // 剩余参数绑定到 obj 对象上

            return typeof re == 'object' ? re : obj; // 如果返回值是对象 name返回对象，否则返回 obj
        }
    ```

## 发布订阅模式，观察者模式的区别及实现，适用场景

