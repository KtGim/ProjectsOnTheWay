# 方案

## 卡片样式

- 1, 4, 8 3种类型

## 布局规则

- 列数 4，行数未知，为了满足自适应采用 antd 的 col 和 row 包裹内部元素

- 采用右下角最大位置来标记 当前元素的位置，其余位置不能使用，使用标记（1，4，8）占用， 遍历到这种节点，直接跳过。

- 每一行的类型 和 行位置需要标记记录，方便计算当前行的起始和终止位置 （1， 表示 一行，4，8 表示两行，与 行左边 index 结合就可以算出当前的位置范围）

## 拖拽后布局更新规则

- 1 与 1 或者 空格可直接置换位置，其他位置不需变动, 8 与 8， 4与4 直接置换， 其他位置不需变动

- 1 与 4(8) 置换 4(8) 上部新增一行 1 直接填入新增行第一格

- 4 与 8 置换， 4所在对应行 元素 直接与 8所在 对应行数置换，其他位置不变

- 同行 4 可以与 1（2）列 1 进行置换(1 上下会被特殊标记为统一行)

- 8 与 1， 4 与 1置换， 1 所在行向下移动两行(坐标 + 8), 8, 4填充到 移动后的 1 的上方，各行情况下会出现空格，需要重新计算位置此时，4 或 8 变动后的上部位置不需变动，变动位置开始需要更新位置信息

- 第一行的置换 需要注意当前坐标是否会小于 0（特殊情况）

## 具体代码实现

- 初始化卡片数据，因为需要兼容老数据，起始位置为 1开始，因此列表第一个数据位置为 0 或者不存在时，需要前端初始化

```javascript
   // 设置 currentList
    useEffect(() => {
        const curBoardList: Array<Array<CardProps>> = [[], [], []];
        const list = curBoard?.kanbanCharts || [];
        setChartsObj({});
        if (list[0] && list[0].position === 0) {
            list.map(item => {
                const { chartEnum, weight } = item;
                if (chartEnum === 'CARD') {
                    curBoardList[0].push(item as CardProps);
                } else if (Number(weight) === 1) {
                    curBoardList[1].push(item as CardProps);
                } else {
                    curBoardList[2].push(item as CardProps);
                }
            });
            let maxPosition: number = 0;
            let maxPositionTemp: number = maxPosition;
            curBoardList[0]
                .sort((a, b) => (a.id || 0) - (b.id || 0))
                .map(item => {
                    item.position = ++maxPosition;
                });
            maxPosition = maxPosition % 4 === 0 ? maxPosition : Math.ceil(maxPosition / 4) * 4;
            curBoardList[1]
                .sort((a, b) => (a.id || 0) - (b.id || 0))
                .map((item, index) => {
                    maxPositionTemp = maxPosition;
                    item.position = index % 2 === 0 ? maxPositionTemp + 6 : maxPositionTemp + 8;
                    if (index % 2 === 1) {
                        maxPosition += 8;
                    }
                });
            maxPosition = maxPosition % 4 === 0 ? maxPosition : Math.ceil(maxPosition / 4) * 4;
            curBoardList[2]
                .sort((a, b) => (a.id || 0) - (b.id || 0))
                .map(item => {
                    item.position = maxPosition + 8;
                    maxPosition += 8;
                });
            const newList = [...curBoardList[0], ...curBoardList[1], ...curBoardList[2]];
            // 删除了 空格之后 需要将位置实时保存到后端
            saveAfterDeleteUndefinedColumns(newList);
            setCurrentList(newList);
        } else {
            setCurrentList(list as CardProps[]);
        }
    }, [haveCurBoard, curBoard]);
```

- 空行删除方法: chartsObj 是用来保存列表数据的 字典类型数据结构 {[position]: cardObj} 对应每个位置的元素数据信息, 当这个数据发生改变表示页面元素需要重新排布。
- positionType 是位置对应的 卡片类型信息 {[position]: 1 | 4 | 8},可以据此来判断将要改变的位置，或者据此

```javascript
  // 除去空行, 保存可填充位置信息
    useEffect(() => {
        if (reloadBoard > 0) {
            const [maxiPosition, positionType] = initList(currentList, chartsObj);
            const [deleteColumnIndex, canContainerBox] = calculateRestPositions(
                maxiPosition,
                positionType
            );
            deleteColumnIndex.forEach((v, index) => {
                /**
                 * 按行空余行， 逐行删除数据
                 * 每次删除位置会进行改变
                 * index = 0 时 , 初始位置开始删除
                 * 在 index > 0 时， v 行数据后 chartsObj[i] 的所有数据都已经进行改变了
                 * 因此计算起始位置时 需要减少空行的索引
                 */
                const beginPosition = index === 0 ? v * 4 : (v - 1) * 4;
                const exchangingPositions = [];
                const exchangedPositions = [];
                for (let i = beginPosition + 1; i <= maxiPosition; i++) {
                    chartsObj[i] &&
                        exchange8Positions({
                            tempObj: chartsObj,
                            originPosition: i,
                            distance: -4,
                            exchangingPositions,
                            exchangedPositions,
                        });
                }
                exchangingPositions.forEach(v => {
                    if (exchangedPositions.indexOf(v) < 0) {
                        delete chartsObj[v];
                    }
                });
            });
            deleteColumnIndex.length > 0 && saveAfterDeleteUndefinedColumns(); // 调用保存接口
            setRestPositions(canContainerBox);
            setCurrentList([...Object.values(chartsObj)]);
        }
        setReloadBoard(reloadBoard + 1);
    }, [chartsObj]);

     // 初始化 list 信息
    const initList = (list, chartsObj): [number, object] => {
        let maxiPosition = 0;
        let positionType = {};
        list.map(board => {
            if (!board) {
                return;
            }
            const { position, weight, chartEnum } = board;
            chartsObj[position] = board;
            chartsObj[position].frontWeight = chartEnum === 'CARD' ? 1 : weight === 1 ? 4 : 8;
            maxiPosition = maxiPosition > position ? maxiPosition : position;
            if (chartEnum === 'CARD') {
                positionType = {
                    ...positionType,
                    [position]: GridType['CARD'],
                };
            } else {
                if (Number(weight) === 1) {
                    // 一倍图 占据上下相邻的 4格
                    positionType = {
                        ...positionType,
                        [position]: GridType['G1'],
                        [position - 1]: GridType['G1'],
                        [position - 4]: GridType['G1'],
                        [position - 5]: GridType['G1'],
                    };
                } else if (Number(weight) === 2) {
                    // 2倍图 占据上下相邻两行
                    for (let i = position - 7; i <= position; i++) {
                        positionType = {
                            ...positionType,
                            [i]: GridType['G2'],
                        };
                    }
                }
            }
        });
        return [maxiPosition, positionType];
    };

    const calculateRestPositions = (maxiPosition: number, positionType: {}): [number[], object] => {
        const maxColumn = maxiPosition % 4 === 0 ? maxiPosition / 4 : Math.ceil(maxiPosition / 4);
        const deleteColumnIndex: number[] = [];
        const canContainerBox: { [key: string]: number[] } = {};
        /**
         * undefinedPositions 保留当前行的数据类型信息
         * 如果该行数据全部是 undefined 表示此行需要被删除
         */
        for (let colNum = 1; colNum <= maxColumn; colNum++) {
            const undefinedPositions: any[] = [];
            for (let i = (colNum - 1) * 4 + 1; i <= 4 * colNum; i++) {
                //undefinedPositions => [1,1,4,undefined]
                undefinedPositions.push(positionType[i]);
            }
            const undefinedLine = undefinedPositions.every(v => !v);
            undefinedLine && deleteColumnIndex.push(colNum);
            // 至少还有一个空位置
            !undefinedLine &&
                // canContainerBox => [[1,1,4,undefined], [undefined,undefined,undefined,undefined]]
                (canContainerBox[colNum] = undefinedPositions);
        }
        return [deleteColumnIndex, canContainerBox];
    };
```

- 位置置换方法

```javascript
  // 遍历替换位置
    const listOfPositions = ({
        tempObj,
        startIndex,
        endIndex,
        distance,
        exchangingPositions,
        exchangedPositions,
    }: listOfPositionsProps) => {
        for (let i = startIndex; i <= endIndex; i++) {
            tempObj[i] &&
                exchange8Positions({
                    tempObj,
                    originPosition: i,
                    distance,
                    exchangingPositions,
                    exchangedPositions,
                });
        }
    };

    // 遍历替换上下2行位置
    const listOfTowLinesPositions = ({
        tempObj,
        startIndex,
        endIndex,
        distance,
        exchangingPositions,
        exchangedPositions,
    }: listOfPositionsProps) => {
        for (let i = startIndex; i <= endIndex; i++) {
            tempObj[i] &&
                exchange8Positions({
                    tempObj,
                    originPosition: i,
                    distance,
                    exchangingPositions,
                    exchangedPositions,
                });
            tempObj[i - 4] &&
                exchange8Positions({
                    tempObj,
                    originPosition: i - 4,
                    distance,
                    exchangingPositions,
                    exchangedPositions,
                });
        }
    };

    // 逆向遍历数据
    const listOfPositionsToReverse = ({
        tempObj,
        startIndex,
        endIndex,
        distance,
        exchangingPositions,
        exchangedPositions,
        excludePosition,
    }: listOfPositionsProps) => {
        for (let i = endIndex; i >= startIndex; i--) {
            i !== excludePosition &&
                tempObj[i] &&
                exchange8Positions({
                    tempObj,
                    originPosition: i,
                    distance,
                    exchangingPositions,
                    exchangedPositions,
                });
        }
    };
```

- 拖拽方法

```javascript
  const drag = (ev, position: number) => {
        const fromColumnIndex = ev.currentTarget.getAttribute('data-column-index');
        ev.dataTransfer.setData('position', position);
        ev.dataTransfer.setData('from-column', fromColumnIndex);
    };

    const drop = ev => {
        ev.preventDefault();
        // 获取移动和目标信息
        const from = ev.dataTransfer.getData('position') - 0;
        const to = ev.currentTarget.getAttribute('data-position') - 0;
        const fromColumnIndex = ev.dataTransfer.getData('from-column') - 0;
        const toColumnIndex = ev.currentTarget.getAttribute('data-column-index') - 0;
        const toList = currentList.filter(v => v.columnIndex === toColumnIndex);
        const toColumnType = getColumnType(toList);
        // 拷贝对像
        const tempObj: ChartsObjProps = chartsObj;
        // 保存移动源信息
        const temp: CardProps = tempObj[from];
        // 保存置换前的 position 信息
        const exchangingPositions: number[] = [];
        // 保存置换后的 position 信息
        const exchangedPositions: number[] = [];
        // 当前列表最大位置
        const curMaxPosition: number = Number(
            Object.keys(tempObj).sort((a, b) => {
                return Number(b) - Number(a);
            })[0]
        );
        // 当前行的 最大位置信息
        let maxPosition: number = Number(
            toList.sort((a, b) => {
                return Number(b.position) - Number(a.position);
            })[0]?.position || 1
        );
        // 当前行的 最小位置信息
        const minPosition: number = Number(
            toList.sort((a, b) => {
                return Number(a.position) - Number(b.position);
            })[0]?.position || 1
        );
        let newFromPosition: number = maxPosition;
        let needResort = true;
        if (from === to || (!tempObj[from] && !tempObj[to])) {
            return;
        }
        if (tempObj[to] && tempObj[from] && tempObj[from].frontWeight === tempObj[to].frontWeight) {
            // 所有类型一致, 直接置换
            const tempTo = tempObj[to];
            tempTo.position = from;
            tempObj[from].position = to;
            tempObj[to] = tempObj[from];
            tempObj[from] = tempTo;
            needResort = false;
        } else if (tempObj[from] && tempObj[from].frontWeight === 8) {
            maxPosition = maxPosition % 4 === 0 ? maxPosition : Math.ceil(maxPosition / 4) * 4;
            newFromPosition = maxPosition;
            // 按当前位置位移的距离
            const distance = (temp?.position || 0) - maxPosition;
            // 默认 部位 CARD 类型的行的起始位置
            let startIndex = maxPosition - 7;
            // 2行 换 2行
            if (toColumnType !== columnType['CARD']) {
                listOfPositions({
                    tempObj,
                    startIndex,
                    endIndex: newFromPosition,
                    distance,
                    exchangingPositions,
                    exchangedPositions,
                });
            } else {
                // 换一行
                let targetPositionDistance = distance;
                startIndex = maxPosition - 3;
                // 中间部分元素位置 需要 向上移动一行
                if (distance < 0) {
                    // distance < 0 小于0 表示从上向下移动
                    // 由于要换到 大图的第一行所以目标的位置要多加 4
                    targetPositionDistance = distance - 4;
                    listOfPositions({
                        tempObj,
                        startIndex: (temp?.position || 0) + 1,
                        endIndex: startIndex - 1,
                        distance: -4,
                        exchangingPositions,
                        exchangedPositions,
                    });
                } else {
                    newFromPosition = maxPosition + 4;
                    listOfPositions({
                        tempObj,
                        startIndex: maxPosition + 5,
                        endIndex: (temp?.position || 0) - 8,
                        distance: 4,
                        exchangingPositions,
                        exchangedPositions,
                    });
                }
                // 被置换行的元素位移策略
                listOfPositions({
                    tempObj,
                    startIndex,
                    endIndex: newFromPosition,
                    distance: targetPositionDistance,
                    exchangingPositions,
                    exchangedPositions,
                });
            }
        } else if (tempObj[from] && tempObj[from].frontWeight === 4) {
            if (fromColumnIndex === toColumnIndex) {
                /**
                 * 同一行置换策略
                 * 当前双行 CARD类型 数据的最大索引 maxCrossRowPosition
                 */
                const couplePosition = ev.currentTarget.getAttribute('data-couple-position') - 0;
                newFromPosition = couplePosition > to ? couplePosition : to;
                // 按当前位置位移距离
                const distance = (temp?.position || 0) - newFromPosition;
                let startIndex = (temp?.position || 0) + 1;
                if (distance > 0) {
                    startIndex = newFromPosition;
                    // 当左移时 由于 2倍图取右下角最大position, 因此遍历时需要取 最大位置 - 1 作为遍历节点终点
                    newFromPosition = (temp?.position || 0) - distance + 1;
                }
                const targetPositionDistance = distance > 0 ? 2 : -2;
                listOfTowLinesPositions({
                    tempObj,
                    startIndex,
                    endIndex: newFromPosition,
                    distance: targetPositionDistance,
                    exchangingPositions,
                    exchangedPositions,
                });
            } else if (toColumnType === columnType['CARD']) {
                newFromPosition =
                    maxPosition % 4 === 0 ? maxPosition + 2 : maxPosition - (maxPosition % 4) + 6;
                listOfPositionsToReverse({
                    tempObj,
                    startIndex: minPosition,
                    endIndex: Number(curMaxPosition),
                    distance: 8,
                    exchangingPositions,
                    exchangedPositions,
                    excludePosition: from,
                });
            } else if (
                toList.length === 1 &&
                maxPosition % 4 === 2 &&
                toColumnType === columnType['ALL1']
            ) {
                newFromPosition = maxPosition + 2;
            } else if (
                toList.length === 1 &&
                maxPosition % 4 === 0 &&
                toColumnType === columnType['ALL1']
            ) {
                newFromPosition = maxPosition - 2;
            } else {
                const toColumnIndexProps = toColumnIndex === 0 ? 0 : toColumnIndex - 1;
                const lastList = currentList.filter(v => v.columnIndex === toColumnIndexProps);
                maxPosition = Number(
                    lastList.sort((a, b) => {
                        return Number(b.position) - Number(a.position);
                    })[0]?.position || 1
                );
                newFromPosition =
                    toColumnIndex === 0
                        ? 6
                        : maxPosition % 4 === 0
                        ? maxPosition + 6
                        : Math.ceil(maxPosition / 4) * 4 + 6;
                listOfPositionsToReverse({
                    tempObj,
                    startIndex: minPosition,
                    endIndex: Number(curMaxPosition),
                    distance: 8,
                    exchangingPositions,
                    exchangedPositions,
                    excludePosition: from,
                });
            }
        } else if (tempObj[from] && tempObj[from].frontWeight === 1) {
            if (!tempObj[to]) {
                exchangePositionsOfCard(tempObj, to, from, from);
                needResort = false;
            } else if (toColumnType !== columnType['CARD']) {
                if (toColumnIndex > 0) {
                    const lastList = currentList.filter(v => v.columnIndex === toColumnIndex - 1);
                    const lastMaxPosition = Number(
                        lastList.sort((a, b) => {
                            return Number(b.position) - Number(a.position);
                        })[0]?.position || 1
                    );
                    newFromPosition =
                        lastMaxPosition % 4 === 0
                            ? lastMaxPosition + 1
                            : lastMaxPosition - (lastMaxPosition % 4) + 5;
                } else {
                    newFromPosition = 1;
                }

                listOfPositionsToReverse({
                    tempObj,
                    startIndex: newFromPosition,
                    endIndex: Number(curMaxPosition),
                    distance: 4,
                    exchangingPositions,
                    exchangedPositions,
                    excludePosition: from,
                });
            }
        } else if (!tempObj[from] && tempObj[to] && tempObj[to].frontWeight === 1) {
            // 来源为空 只能与 权重为 1 的卡片 置换
            exchangePositionsOfCard(tempObj, from, to, to);
            needResort = false;
        }
        if (needResort && temp) {
            /**
             * 直接置换位置时 不做以下操作
             * 计算 from 位置的卡片信息， 由于置过程会导致 tempObj[from] 被改变，因此 使用 temp变量保存
             *
             */
            temp.position = newFromPosition;
            tempObj[newFromPosition] = temp;
            exchangingPositions.push(from);
            exchangedPositions.push(newFromPosition);
            /**
             * 改变后的位置上没有改变前的位置，就删除对象上该位置的数据, 保证 tempObj 的完整性，使数据量统一
             * 置换过程中 同一位置信息 后者会自动替换前者， 但是 空余位置的 置换，还是会保留已有位置的信息
             */
            exchangingPositions.forEach(v => {
                if (exchangedPositions.indexOf(v) < 0) {
                    delete tempObj[v];
                }
            });
        }
        setChartsObj({ ...tempObj });
    };

    const exchange8Positions = ({
        tempObj,
        originPosition,
        distance,
        exchangingPositions,
        exchangedPositions,
    }) => {
        const targetPosition = tempObj[originPosition].position + distance;
        tempObj[originPosition].position = targetPosition;
        tempObj[targetPosition] = tempObj[originPosition];
        exchangingPositions.push(originPosition);
        exchangedPositions.push(targetPosition);
    };

    // 1倍卡片 与 空位置互相置换
    const exchangePositionsOfCard = (tempObj, from, to, deletePosition) => {
        // 某一个为 undefined 此时 类型相同就直接置换
        tempObj[to].position = from;
        tempObj[from] = tempObj[to];
        delete tempObj[deletePosition];
    };
```

-重置方法, 触发 hooks 机制

```javascript
  const resetKB = (list: CardProps[] = []) => {
      const tempChartsObj = {};
      const [] = initList(list, tempChartsObj);
      setCurrentList(list);
      setChartsObj(tempChartsObj);
      setSortable(false);
  };
```

- 布局 需要使用 antd col 和 row,并且 组件 card 外部构造不同，所以业务代码比较冗余

```javascript
  // 计算布局信息
    useEffect(() => {
        let columnIndex: number = 0;
        let colNum = 1;
        const crossColumnsObj: object = {};
        const skipPositions: number[] = [];
        if (currentList && currentList.length > 0) {
            const [maxiPosition, positionType] = initList(currentList, chartsObj);
            setChartsObj(chartsObj);
            // 整体渲染数组
            const columns: Array<Array<JSX.Element>> = [];
            // 当前一组元素
            let curRowProps: JSX.Element[] = [];
            // 每一组卡片的最终位置
            let curSearchFinalPosition = 0;
            let curSkipPositions: number[] = [];
            // 当前行渲染位置
            let index = 0;
            for (let i = 1; i <= maxiPosition; i++) {
                curSkipPositions = skipPositions.slice(0);
                // 计算当前一行的最终位置
                curSearchFinalPosition = i % 4 > 0 ? (Math.floor(i / 4) + 1) * 4 : i;
                /**
                 * 是否需要占领两行， 当前组中有站多行的元素 需要跨行， curSearchFinalPosition 直接加 4
                 */
                for (let j = i; j <= curSearchFinalPosition; j++) {
                    if (positionType[j] === GridType['G1']) {
                        curSearchFinalPosition += 4;
                        crossColumnsObj[colNum++] = columnIndex;
                        break;
                    }
                }
                /**
                 * positionType[j] 为 undefined 表示此位置为空位
                 */
                for (let j = i; j <= curSearchFinalPosition; j++) {
                    if (
                        curSkipPositions.indexOf(j) > -1 ||
                        (!chartsObj[j] && positionType[j] !== GridType['CARD'] && positionType[j])
                    ) {
                        // 不需要计算就直接进入下一个循环
                        continue;
                    }
                    // 当前位置的 类型
                    const curChartType = positionType[j];
                    const curChart = chartsObj[j] || {};
                    const { chartViewType, name, id, weight } = curChart;
                    curChart.columnIndex = columnIndex;
                    const Component = chartsEnum[chartViewType || ''] as (
                        props: any
                    ) => JSX.Element;
                    if (curChartType === GridType['G1'] || curChartType === GridType['G2']) {
                        index =
                            curChartType === GridType['G1']
                                ? j % 4 === 0
                                    ? curChartType === GridType['G2']
                                        ? 0
                                        : 3
                                    : (j % 4) - 1
                                : 0;
                        curRowProps[index] = (
                            <Col
                                key={`card_${j}_${id}`}
                                className={styles['padding-10']}
                                span={(weight || 1) * 12}
                                draggable={sortable}
                                onDragStart={e => drag(e, j)}
                                data-position={j}
                                data-column-index={columnIndex}
                                onDrop={drop}
                                onDragOver={allowDrop}
                            >
                                {isCustomerChartsEnum[chartViewType || ''] ? (
                                    getCustomerChart(chartViewType, curChart)
                                ) : (
                                    <Component
                                        spaceType={spaceType}
                                        chartName={name}
                                        edit={() => {
                                            if (sortable) {
                                                message.info('排序过程中，不能进行此项操作');
                                                return;
                                            }
                                            setChartData(chartsObj[j]);
                                            setChartVisible(true);
                                        }}
                                        del={() => {
                                            if (sortable) {
                                                message.info('排序过程中，不能进行此项操作');
                                                return;
                                            }
                                            deleteChart(id);
                                        }}
                                    />
                                )}
                            </Col>
                        );
                        // 整行沾满，直接跳出循环s
                        if (curChartType === GridType['G2']) {
                            break;
                        }
                    } else if (curChartType === GridType['CARD'] || !curChartType) {
                        // 当前位置 相隔的下一个位置
                        let skipChartType = positionType[j + 2];
                        /**
                         * 当相隔位置 均为 GridType['CARD'] 时表示 整行都是 GridType['CARD']
                         * 当位置 为 3，4 就查看 1，2， 位置的类型
                         */
                        if (j > 2 && (j % 4 === 0 || j + 2 > Math.floor(j / 4) * 4 + 4)) {
                            skipChartType = positionType[j - 2];
                        }
                        const index = j % 4 === 0 ? 3 : (j % 4) - 1;
                        if (skipChartType === GridType['CARD'] || !skipChartType) {
                            curRowProps[index] = (
                                <Col
                                    key={`card_${j}_${id}`}
                                    className={styles['padding-10']}
                                    span="6"
                                    draggable={sortable}
                                    onDragStart={e => drag(e, j)}
                                    data-position={j}
                                    data-column-index={columnIndex}
                                    onDrop={drop}
                                    onDragOver={allowDrop}
                                >
                                    {chartsObj[j] ? (
                                        <CardShell
                                            edit={() => {
                                                if (sortable) {
                                                    message.info('排序过程中，不能进行此项操作');
                                                    return;
                                                }
                                                setChartData(chartsObj[j]);
                                                setChartVisible(true);
                                            }}
                                            del={() => {
                                                if (sortable) {
                                                    message.info('排序过程中，不能进行此项操作');
                                                    return;
                                                }
                                                deleteChart(id);
                                            }}
                                        >
                                            <Component spaceType={spaceType} chartName={name} />
                                        </CardShell>
                                    ) : (
                                        <div
                                            key={`card_${j}_${id}`}
                                            className={`board-container-card__empty ${
                                                sortable && 'board-container-card__bg'
                                            }`}
                                        ></div>
                                    )}
                                </Col>
                            );
                        } else {
                            const nextColumnColPosition =
                                j === curSearchFinalPosition ? j - 4 : j + 4;
                            const nextColumnCol = chartsObj[nextColumnColPosition];
                            const NextComponent =
                                nextColumnCol &&
                                (chartsEnum[nextColumnCol?.chartViewType || ''] as (
                                    props: any
                                ) => JSX.Element);
                            if (nextColumnCol) {
                                nextColumnCol.columnIndex = columnIndex;
                            }
                            curRowProps[index] = (
                                <Col
                                    key={`card_container_${j}_${id}`}
                                    className={styles['padding-10']}
                                    span="6"
                                >
                                    {j === curSearchFinalPosition && (
                                        <Row>
                                            <Col
                                                span="24"
                                                draggable={sortable}
                                                onDragStart={e => drag(e, j - 4)}
                                                data-position={j - 4}
                                                data-couple-position={j}
                                                data-column-index={columnIndex}
                                                onDrop={drop}
                                                onDragOver={allowDrop}
                                                key={`card_${j - 4}_${id}`}
                                            >
                                                {isCustomerChartsEnum[chartViewType || ''] ? (
                                                    getCustomerChart(chartViewType, curChart)
                                                ) : nextColumnCol && NextComponent ? (
                                                    <CardShell
                                                        edit={() => {
                                                            if (sortable) {
                                                                message.info(
                                                                    '排序过程中，不能进行此项操作'
                                                                );
                                                                return;
                                                            }
                                                            setChartData(nextColumnCol);
                                                            setChartVisible(true);
                                                        }}
                                                        del={() => {
                                                            if (sortable) {
                                                                message.info(
                                                                    '排序过程中，不能进行此项操作'
                                                                );
                                                                return;
                                                            }
                                                            deleteChart(nextColumnCol.id, j - 4);
                                                        }}
                                                    >
                                                        <NextComponent
                                                            spaceType={spaceType}
                                                            chartName={nextColumnCol.name}
                                                        />
                                                    </CardShell>
                                                ) : (
                                                    <div
                                                        key={`card_${j + 4}_${id}`}
                                                        className={`board-container-card__empty ${
                                                            sortable && 'board-container-card__bg'
                                                        }`}
                                                    ></div>
                                                )}
                                            </Col>
                                        </Row>
                                    )}
                                    <Row style={{ marginBottom: 20 }}>
                                        <Col
                                            span="24"
                                            draggable={sortable}
                                            onDragStart={e => drag(e, j)}
                                            data-position={j}
                                            data-couple-position={nextColumnColPosition}
                                            data-column-index={columnIndex}
                                            onDrop={drop}
                                            onDragOver={allowDrop}
                                            key={`card_${j}_${id}`}
                                        >
                                            {isCustomerChartsEnum[chartViewType || ''] ? (
                                                getCustomerChart(chartViewType, curChart)
                                            ) : chartsObj[j] ? (
                                                <CardShell
                                                    edit={() => {
                                                        if (sortable) {
                                                            message.info(
                                                                '排序过程中，不能进行此项操作'
                                                            );
                                                            return;
                                                        }
                                                        setChartData(chartsObj[j]);
                                                        setChartVisible(true);
                                                    }}
                                                    del={() => {
                                                        if (sortable) {
                                                            message.info(
                                                                '排序过程中，不能进行此项操作'
                                                            );
                                                            return;
                                                        }
                                                        deleteChart(id, j);
                                                    }}
                                                >
                                                    <Component
                                                        spaceType={spaceType}
                                                        chartName={name}
                                                    />
                                                </CardShell>
                                            ) : (
                                                <div
                                                    key={`card_${j}_${id}`}
                                                    className={`board-container-card__empty ${
                                                        sortable && 'board-container-card__bg'
                                                    }`}
                                                ></div>
                                            )}
                                        </Col>
                                    </Row>
                                    {j !== curSearchFinalPosition && (
                                        <Row>
                                            <Col
                                                span="24"
                                                draggable={sortable}
                                                onDragStart={e => drag(e, j + 4)}
                                                data-position={j + 4}
                                                data-couple-position={j}
                                                data-column-index={columnIndex}
                                                onDrop={drop}
                                                onDragOver={allowDrop}
                                                key={`card_${j + 4}_${id}`}
                                            >
                                                {isCustomerChartsEnum[chartViewType || ''] ? (
                                                    getCustomerChart(chartViewType, curChart)
                                                ) : nextColumnCol && NextComponent ? (
                                                    <CardShell
                                                        edit={() => {
                                                            if (sortable) {
                                                                message.info(
                                                                    '排序过程中，不能进行此项操作'
                                                                );
                                                                return;
                                                            }
                                                            setChartData(nextColumnCol);
                                                            setChartVisible(true);
                                                        }}
                                                        del={() => {
                                                            if (sortable) {
                                                                message.info(
                                                                    '排序过程中，不能进行此项操作'
                                                                );
                                                                return;
                                                            }
                                                            deleteChart(nextColumnCol.id, j + 4);
                                                        }}
                                                    >
                                                        <NextComponent
                                                            spaceType={spaceType}
                                                            chartName={nextColumnCol.name}
                                                        />
                                                    </CardShell>
                                                ) : (
                                                    <div
                                                        key={`card_${j + 4}_${id}`}
                                                        className={`board-container-card__empty ${
                                                            sortable && 'board-container-card__bg'
                                                        }`}
                                                    ></div>
                                                )}
                                            </Col>
                                        </Row>
                                    )}
                                </Col>
                            );
                            curSkipPositions.push(nextColumnColPosition);
                        }
                    }
                }
                crossColumnsObj[colNum++] = columnIndex;
                if (curRowProps.length > 0) {
                    columns.push(curRowProps);
                    columnIndex++;
                }
                i = curSearchFinalPosition; // 直接跳过被覆盖区域
                curSearchFinalPosition = 0;
                curRowProps = [];
            }
            setCrossColumnsIndexObj(crossColumnsObj);
            setSortChartList(columns);
        } else {
            setSortChartList([]);
        }
    }, [currentList, reloadBoard, sortable]);
```